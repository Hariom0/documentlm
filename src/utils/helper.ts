import cohere from "@/config/cohereConfig";
import { PDFParse } from "pdf-parse";
import wordExtractor from "word-extractor";
import path from "path";
import { readdir, unlink } from "fs/promises";
import fs from "fs/promises";

const FILE_PATH = path.join(process.cwd(), "public", "input.json");

export type McqItem = {
	question: string;
	options: string[];
	correctAnswer: string;
	reference?: string;
};

export type SummaryResult = {
	summary: string;
	mcqs: McqItem[];
};

export async function getSummary(inputData: string): Promise<SummaryResult> {
	const response = await cohere.chat({
		model: "command-r-plus-08-2024",
		temperature: 0.3,
		messages: [
			{
				role: "system",
				content: `You are an expert educator, examiner, and content creator specializing in designing technical assessments.

Your task is to analyze the provided study notes (or topic name, if detailed content is not given) and generate a valid JSON response that strictly follows this schema:

{
  "summary": string,
  "mcqs": [
    {
      "question": string,
      "options": string[],
      "correctAnswer": string,
      "reference"?: string
    }
  ]
}

Instructions & Rules:

1. Summary Section:
   - Provide a concise and well-written summary (3-5 sentences) describing the main topic, core concepts, and relevance.
   - If only a topic name is given, generate a general academic overview of that topic.

2. MCQs Section (must contain exactly 20 questions):
   - Always generate exactly 20 MCQs, no matter how short the notes are.
   - Each MCQ must have:
     - A clear, single-correct question (question)
     - 4 distinct answer choices (options)
     - One correct answer (correctAnswer)
     - A reference field (reference) describing where it came from:
       - If based on provided notes, mention a section or concept name, e.g., "Locks section".
       - If generated by AI due to insufficient content, use "AI-generated" or "AI-based expansion".

3. Question Variety:
   - Include a mix of:
     - Approximately 70% conceptual / theoretical questions
     - Approximately 30% numerical, logical, or applied scenario-based questions
   - Vary the difficulty from easy to moderate to challenging.

4. Content Quality:
   - Avoid duplicate or trivially reworded questions.
   - Maintain conceptual relevance to the main topic.
   - Ensure all answer options are plausible distractors.

5. Formatting:
   - Output only valid JSON — no explanations, markdown, or commentary.
   - Maintain proper JSON escaping and structure.

6. Fallback Behavior:
   - If the provided notes are too short or missing, infer the main subject and generate high-quality AI-based questions consistent with that domain.

7. Example Behavior:
   Input: "POSIX Threads and Synchronization"
   Output: JSON containing a short topic summary and exactly 20 MCQs related to POSIX threads, mixing theoretical and practical questions, with references like "Locks section", "Condition Variables section", or "AI-generated".

Remember: The response must be 100% valid JSON following the above schema.`,
			},
			{
				role: "user",
				content: inputData,
			},
		],
		responseFormat: {
			type: "json_object",
			jsonSchema: {
				type: "object",
				properties: {
					summary: { type: "string" },
					mcqs: {
						type: "array",
						items: {
							type: "object",
							properties: {
								question: { type: "string" },
								options: { type: "array", items: { type: "string" } },
								correctAnswer: { type: "string" },
								reference: { type: "string" },
							},
							required: ["question", "options", "correctAnswer"],
						},
					},
				},
				required: ["summary", "mcqs"],
			},
		},
	});

	// Cohere returns JSON as a string in the message content
	/*
 EARLIER USED, GIVES AN ERROR-- CHANGED TO extract text from message content
  const content = response?.message?.content?.[0]?.text ?? "";
*/

	const content =
		response?.message?.content
			?.filter((c: any) => c.type === "text")
			?.map((c: any) => c.text)
			?.join(" ") ?? "";

	try {
		const parsed = JSON.parse(content);
		return parsed as SummaryResult;
	} catch (err) {
		console.error("Failed to parse Cohere response:", err, content);
		return { summary: content || "", mcqs: [] };
	}
}

export async function extractPdf(filePath: string) {
	const parser = new PDFParse({ url: filePath });
	const result = await parser.getText();
	const checkedText = typeof result === "string" ? result : result.text;
	return cleanText(checkedText);
}

export async function extractDoc(filePath: string) {
	const extractor = new wordExtractor();
	const ex = await extractor.extract(filePath);
	return cleanText(ex.getBody());
}

export function cleanText(rawText: string) {
	return rawText
		.replace(/\r\n/g, "\n")
		.replace(/[ \t]+/g, " ")
		.replace(/\n{2,}/g, "\n\n")
		.trim();
}
export async function extractUploads(uploadDir: string) {
	const files = await readdir(uploadDir);
	let uploadedText = "";

	for (const file of files) {
		const extName = path.extname(file).toLowerCase();
		const filePath = path.join(uploadDir, file);

		if (extName === ".pdf") {
			uploadedText += await extractPdf(filePath);
			await unlink(filePath);
		} else if (extName === ".docx" || extName === ".doc") {
			uploadedText += await extractDoc(filePath);
			await unlink(filePath);
		}
	}

	return uploadedText;
}

export function convertToGoogleFormRequests(aiOutput: any) {
	if (!aiOutput || !Array.isArray(aiOutput.mcqs)) {
		throw new Error("Invalid input format. Expected object with 'mcqs' array.");
	}

	const requests = [];
	let index = 0;

	if (aiOutput.summary) {
		requests.push({
			createItem: {
				item: {
					title: "Chapter Summary",
					description: aiOutput.summary,
					pageBreakItem: {},
				},
				location: { index: index++ },
			},
		});
	}

	// MCQ as a Multiple Choice question
	aiOutput.mcqs.forEach((mcq: any, i: number) => {
		const questionTitle = mcq.question || `Question ${i + 1}`;
		const options = (mcq.options || []).map((opt: any) => ({ value: opt }));

		requests.push({
			createItem: {
				item: {
					title: questionTitle,
					description: mcq.reference ? `Reference: ${mcq.reference}` : undefined,
					questionItem: {
						question: {
							required: true,
							choiceQuestion: {
								type: "RADIO",
								options: options,
								shuffle: false,
							},
						},
					},
				},
				location: { index: index++ },
			},
		});
	});

	return { requests };
}

export async function saveInputJson(data: any) {
	try {
		if (!data || typeof data !== "object") {
			return { success: false, error: "Invalid JSON payload" };
		}

		// Convert object → JSON string
		const jsonString = JSON.stringify(data, null, 2);

		await fs.writeFile(FILE_PATH, jsonString, "utf8");

		return { success: true, message: "File saved successfully" };
	} catch (err: any) {
		return { success: false, error: "Failed to write file: " + err.message };
	}
}

export async function readInputJson() {
	try {
		// Check if file exists
		await fs.access(FILE_PATH);

		const fileContent = await fs.readFile(FILE_PATH, "utf8");
		const json = JSON.parse(fileContent);

		return { success: true, data: json };
	} catch (err: any) {
		if (err.code === "ENOENT") {
			return { success: false, error: "File not found" };
		}
		return { success: false, error: "Failed to read file: " + err.message };
	}
}
